float _mem_is_init()
    say :(:0);

float _mem_set_init()
    :(:0) = 1;

float _block_number()
    say :((:0) + 1);

float _block_number_set(float value)
    :((:0) + 1) = value;

float _first_block_addr()
    say (:0) + 2;

float _mem_size()
    say 50000 - _first_block_addr();

float _block_size(float block_addr)
    say :block_addr;

float _block_size_set(float block_addr, float size)
    :block_addr = size;

float _block_free(float block_addr)
    say :block_addr + 1;

float _block_free_set(float block_addr, float free)
    :block_addr + 1 = free;

float _next_block_addr(float block_addr) 
{
    var block_size = _block_size(block_addr);
    var block_size_end = block_addr + block_size + 1;
    if(block_size_end  == _mem_size())
    {
        say -1;
    }

    say block_size_end + 1;
}

float _previous_block_addr(float block_addr) 
{
    var first_block_addr = _first_block_addr();
    if(block_addr <= first_block_addr)
    {
        say -1;
    }

    var previous_block_addr = first_block_addr;
    var current_block_addr = _next_block_addr(previous_block_addr);
    while(current_block_addr < block_addr)
    {
        previous_block_addr = current_block_addr;
        current_block_addr = _next_block_addr(previous_block_addr);
    }
    say previous_block_addr;
}

float _next_block_create(float block_addr, float initial_size)
{
    var next_block_addr = _next_block_addr(block_addr);
    if(next_block_addr != -1)
    {
        var block_size = _block_size(block_addr);
        var block_total_size = block_size + 2;
        var next_block_size = initial_size - block_total_size;
        _block_size_set(next_block_addr, next_block_size);
        _block_free_set(next_block_addr, true);
    }
}

float _block_fusion_right(float block_addr)
{
    if(block_addr < _first_block_addr())
    {
        say -1;
    }

    var block_free = _block_free(block_addr);
    var block_size = _block_size(block_addr);
    if(block_free)
    {
        var next_block_addr = _next_block_addr(block_addr);
        if(next_block_addr != -1)
        {
            var next_block_free = _block_free(next_block_addr);
            var next_block_size = _block_size(next_block_addr);
            if(next_block_free)
            {
                var block_fusion_size = block_size + next_block_size + 2;
                _block_size_set(block_addr, block_fusion_size);
            }
        }
    }
}

float _init_mem()
{
    if(!_mem_is_init())
    {
        _mem_set_init();
        var block_addr = _first_block_addr();
        _block_size_set(block_addr, _mem_size() - 2);
        _block_free_set(block_addr, true);
    }
}

float bmem(float required_size)
{
    _init_mem();

    var block_addr = _first_block_addr();
    var free_addr = -1;
    while(free_addr == -1) 
    {
        var block_size = _block_size(block_addr);
        var block_free = _block_free(block_addr);
        if(block_size >= required_size && block_free)
        {
            free_addr = block_addr;
            _block_size_set(block_addr, required_size);
            _block_free_set(block_addr, false);
            if(block_size > required_size)
            {
                _next_block_create(block_addr, block_size);
            }
        }
        else 
        {
            block_addr = _next_block_addr(block_addr);
            if(block_addr == -1)
            {
                say -1;
            }
        }
    }
    _block_number_set(_block_number() + 1);
    say free_addr + 2;
}

float rmem(float pointer)
{
    var block_addr = pointer - 2;
    _block_free_set(block_addr, true);
    _block_fusion_right(block_addr);
    _block_fusion_right(_previous_block_addr(block_addr));
    _block_number_set(_block_number() - 1);
}

float size(float pointer) 
    say _block_size(pointer - 2);

float init_array(float pointer, float dim_pointer, float dim_pointer_size)
{
    if(dim_pointer_size == 1)
        say :dim_pointer;
        
    var current_dim = :dim_pointer;
    var child_size = 0;
    for(var i = 0; i < current_dim; i++)
    {
        var child_pointer = pointer + current_dim + (i * child_size);
        child_size = init_array(child_pointer, dim_pointer + 1, dim_pointer_size - 1);
        :pointer + i = child_pointer;
    }
    say current_dim * (child_size + 1);
}

float display(float pointer)
{
    var block_addr = pointer - 2;
    var block_size = _block_size(block_addr);
    for(var i = 0; i < block_size; i++) 
    {
        print :pointer + i;
    }
}

float pow(float a, float b)
{
    if(b == 0)
    {
        say 1;
    }
    
    if(b < 0)
    {
        say 1 / pow(a, -b);
    }

    while(b > 0)
    {
        a *= a;
        b--;
    }
    say a;
}

float linked_list_next(float list)
    say :list + 1;

float linked_list_next_set(float list, float value)
    :list + 1 = value;

float linked_list_value(float list)
    say :list;

float linked_list_value_set(float list, float value)
    :list = value;

float linked_list_size(float list)
{
    if(linked_list_next(list) == 0)
        say 1;
    say 1 + linked_list_size(linked_list_next(list));
}

float linked_list_last(float list)
{
    while(linked_list_next(list) != 0)
    {
        list = linked_list_next(list);
    }
    say list;
}

float linked_list_new(float value) 
{
    var list = bmem(2);
    linked_list_value_set(list, value);
    say list;
}

float linked_list_add(float list, float value)
{
    var last = linked_list_last(list);
    var new = linked_list_new(value);
    linked_list_next_set(last, new);
}

float linked_list_remove(float list, float index)
{
    var length = linked_list_size(list);
    if(index >= length)
        say list;

    if(index == 0)
    {
        var next = linked_list_next(list);
        rmem(list);
        say next;
    }
    else
    {   
        var before = list;
        for(var i = 0; i < index - 1; i++)
        {
            before = linked_list_next(before);
        }
        if(index == length - 1)
        {
            rmem(linked_list_next(before));
            linked_list_next_set(before, 0);
        }
        else 
        {
            var removable = linked_list_next(before);
            var next = linked_list_next(removable);
            linked_list_next_set(before, next);
            rmem(removable);
        }
        say list;
    }
}

float linked_list_display_values(float list)
{
    var length = linked_list_size(list);
    for(var i = 0; i < length; i++)
    {
        print linked_list_value(list);
        list = linked_list_next(list);
    }
}